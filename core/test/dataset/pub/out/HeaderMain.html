<head>
    <meta charset="UTF-8">
    <link href="../../../../../www/css/bootstrap-5.1.3-dist/main.css" rel="stylesheet">
    <script src="../../../../../www/css/bootstrap-5.1.3-dist/main.js"></script>
    <link rel="stylesheet" href="../../../../../www/css/main.min.css">
    <link rel="stylesheet" href="../../../../../www/css/plugin.css">
</head>
<div id="menu">

    <!-- Скрыть оглавление -->
    <input type="button" id="bt_show_menu" value="<<"
           onclick="detail_menu.hidden=false;bt_show_menu.hidden=true;bt_hidden_menu.hidden=false;menu.style.height = '50%';menu.style.width = '35%';">
    <!-- Развернуть оглавление -->
    <input type="button" id="bt_hidden_menu" value=">>"
           onclick="detail_menu.hidden=true;bt_show_menu.hidden=false;  bt_hidden_menu.hidden=true;menu.style.height = '50px';menu.style.width = '50px';"/>
    <!-- Темы оглавления -->
    <div id="detail_menu">
        <ol>
            <ol><li><a href="#Стек технологий">Стек технологий</a></li><ol><li><a href="#БД">БД</a></li><ol><li><a href="#SQL">SQL</a></li><li><a href="#NoSQL">NoSQL</a></li></ol><li><a href="#Frontend">Frontend</a></li><li><a href="#Брокеры сообщений">Брокеры сообщений</a></li><li><a href="#Диплой">Диплой</a></li></ol><li><a href="#Ссылки на документацию">Ссылки на документацию</a></li><li><a href="#Ошибки">Ошибки</a></li><ol></ol><li><a href="#Готовые решения задач">Готовые решения задач</a></li><li><a href="#Регулярные выражения">Регулярные выражения</a></li><ol><li><a href="#Ключевые слова">Ключевые слова</a></li><li><a href="#Сокращения">Сокращения</a></li><li><a href="#Квантификаторы (указание количества повторений)">Квантификаторы (указание количества повторений)</a></li></ol><li><a href="#Функции библиотеки `re`">Функции библиотеки `re`</a></li><ol><li><a href="#Операции с результатом">Операции с результатом</a></li><li><a href="#re.match()">re.match()</a></li><li><a href="#re.search()">re.search()</a></li><li><a href="#re.findall()">re.findall()</a></li><li><a href="#re.finditer()">re.finditer()</a></li><li><a href="#re.split()">re.split()</a></li><li><a href="#re.sub()">re.sub()</a></li></ol><li><a href="#буквы буквы ыфвывфыв 127.0.0.0:_ фв ы фы фы">буквы буквы ыфвывфыв 127.0.0.0:_ фв ы фы фы</a></li><ol><li><a href="#Группировка результата">Группировка результата</a></li></ol><li><a href="#Примеры">Примеры</a></li><ol><li><a href="#Форматирование SQL">Форматирование SQL</a></li></ol><li><a href="#Тестирование">Тестирование</a></li><ol><li><a href="#`UnitTest`">`UnitTest`</a></li><li><a href="#`DocTest`">`DocTest`</a></li><li><a href="#`Pytest`">`Pytest`</a></li></ol><li><a href="#Картеж с именами аргументов, массив со значениями для аргументов">Картеж с именами аргументов, массив со значениями для аргументов</a></li><li><a href="#Ожидать возникновение ошибки">Ожидать возникновение ошибки</a></li><li><a href="#Пропустить весь тест">Пропустить весь тест</a></li><li><a href="#Пропустить тест в теле функции">Пропустить тест в теле функции</a></li><ol><li><a href="#Проект для тестирования">Проект для тестирования</a></li></ol><li><a href="#Логирование - `loguru`">Логирование - `loguru`</a></li><ol><li><a href="#Настройка логирования">Настройка логирования</a></li><li><a href="#Декораторы логирования">Декораторы логирования</a></li></ol>
        </ol>
    </div>
    <script>
        bt_show_menu.hidden = true;
        // Переход к заголовку по нажатию элемент оглавления.
        document.querySelectorAll("#detail_menu li").forEach((e) => {
            e.onclick = ()=>{
              window.location.href  = e.children[0].href
            }
          }
        );
    </script>
</div>
<h1 id="Стек технологий" class="MarkdownDRY StandardHeaders">Стек технологий</h1>


Вам грозит `#` если вы потеряете конфиденциальные данные клиентов. Ну или две ##
, разные случаи в жизни бывают


<h2 id="БД" class="MarkdownDRY StandardHeaders">БД</h2>



<h3 id="SQL" class="MarkdownDRY StandardHeaders">SQL</h3>


Нормальные реляционные БД


<h3 id="NoSQL" class="MarkdownDRY StandardHeaders">NoSQL</h3>


Не нормальные не реляционные БД


<h2 id="Frontend" class="MarkdownDRY StandardHeaders">Frontend</h2>


JavaScript


<h2 id="Брокеры сообщений" class="MarkdownDRY StandardHeaders">Брокеры сообщений</h2>


Курьер, приходит в понедельник и четверг в 12 часов дня.


<h2 id="Диплой" class="MarkdownDRY StandardHeaders">Диплой</h2>


В диплое главное - чтоб бекапы были рабочего варианты.


<h1 id="Ссылки на документацию" class="MarkdownDRY StandardHeaders">Ссылки на документацию</h1>


Зачем нам документация ? Все же и так понятно ! Смотри в код, читай, понимай.


<h1 id="Ошибки" class="MarkdownDRY StandardHeaders">Ошибки</h1>


Ошибки не волк, прод повалить и в вечер пятницы. Так что не ошибайся, и тогда не
будет ошибок.


<h2 id="Ошибки связанные с API" class="MarkdownDRY HiddenHeaders">Ошибки связанные с API</h2>


Во всем виноваты Бекендеры.


<h2 id="Ошибки связанные с БД" class="MarkdownDRY HiddenHeaders">Ошибки связанные с БД</h2>


Во всем виноваты Администраторы БД.


<h2 id="Ошибки в UI" class="MarkdownDRY HiddenHeaders">Ошибки в UI</h2>


Во всем виноваты Фронтедеры


<h2 id="Ошибки связанные с VPN" class="MarkdownDRY HiddenHeaders">Ошибки связанные с VPN</h2>


Во всем виноваты Девопсеры


<h2 id="Ошибки связанные с Легаси кодом" class="MarkdownDRY HiddenHeaders">Ошибки связанные с Легаси кодом</h2>


Эт не я делал, так что, виноваты прошлые разрабы которые документацию не
оставили. Разбирайся как-нибудь сам ...

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>


<h1 id="Готовые решения задач" class="MarkdownDRY StandardHeaders">Готовые решения задач</h1>


Если вам нужно вывести в консоль "Привет мир", то тогда воспользуйтесь гуглом, и
поищите там ответ.

------------------


<h1 id="Регулярные выражения" class="MarkdownDRY StandardHeaders">Регулярные выражения</h1>


Регулярными выражениями называются шаблоны, которые используются для поиска соответствующего фрагмента текста и сопоставления символов.

По сути, наш шаблон — это набор символов, который проверяет строку на соответствие заданному правилу. Давайте разберёмся, как это работает.


<h2 id="Ключевые слова" class="MarkdownDRY StandardHeaders">Ключевые слова</h2>


- [Онлайн редактор регулярных выражений](https://pythex.org/)
- [Ссылка на хороший видео урок про регулярные выражения ](https://www.youtube.com/watch?v=1SWGdyVwN3E)
- [Статья про регулярные выражения](https://tproger.ru/translations/regular-expression-python/)
- https://docs.python.org/3/library/re.html
- https://habr.com/ru/post/349860/
- [Сайт для проверки регулярных выражений](https://regex101.com/)
- [Видео урок о регулярных выражениях](https://www.youtube.com/watch?v=K8L6KVGG-7o)
- [Доп модуль для REGEX с подержкой рекурсии](https://pypi.org/project/regex/)


<h3 id="Сокращения" class="MarkdownDRY StandardHeaders">Сокращения</h3>


| Знак | Описание                       | Аналог          |
| ---- | ------------------------------ | --------------- |
| `\d` | Любая цифра                    | `[0-9]`         |
| `\D` | Любая **не** цифра             | `[^0-9]`        |
| `\w` | Любая буква,цифра,`_`          | `[A-Za-z0-9_]`  |
| `\W` | Любая **не** буква,цифра,`_`   | `[^A-Za-z0-9_]` |
| `\s` | Любой пробельный символ        | `[\n\t ]`       |
| `\S` | Любой **не** пробельный символ | `[^\n\t ]`      |
| ---  | ---                            | ---             |
| `\A` | Начало текст                   |                 |
| `\Z` | Конец текста                   |                 |

- `(?:\A|\n)` - Начало строки или перенос


<h3 id="Квантификаторы (указание количества повторений)" class="MarkdownDRY StandardHeaders">Квантификаторы (указание количества повторений)</h3>


| Символ         | Обозначение                                                           |
| -------------- | --------------------------------------------------------------------- |
| `?`            | 0 или 1 вхождение шаблона слева                                       |
| `+`            | 1 и более вхождений шаблона слева                                     |
| `*`            | 0 и более вхождений шаблона слева                                     |
| `{Старт,Стоп}` | От `Старт` до `Стоп` вхождений. Можно не указывать `Старт` или `Стоп` |

- Сделать квантификатор ленивым
    ```bash
    *?
    +?
    ??
    {m,n}?
    {,n}?
    {m,}?
    ```
    Пример использования
    ```bash
    re.findall('\(.*\)','(a + b) * (c + d) * (e +f)')
    # Жадный вариант - он берет последнию найденую скобку
    >>['(a + b) * (c + d) * (e +f)']
    ```
    ```bash
    re.findall('\(.*?\)','(a + b) * (c + d) * (e +f)')
    # Лениый вариант - он бете первую найденую скобку
    >>['(a + b)','(c + d)','(e +f)']
    ```


<h3 id="Ключевые слова" class="MarkdownDRY StandardHeaders">Ключевые слова</h3>


| Символ                     | Обозначение                                                                                                                                                             |
| -------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `.`                        | Один любой символ, кроме `\n`                                                                                                                                           |
| `[ ]`                      | Один из символов в скобках                                                                                                                                              |
| `[^ ]`                     | Любой символ, кроме тех, что в скобках                                                                                                                                  |
| `[\w\W][^\n]+`             | Можно комбинировать исключение, например любой символы кроме переноса строки, для указания нескольких исключений символов нужно писать по отдельности квадратные скобки |
| `\`                        | Экранирование специальных символов                                                                                                                                      |
| `^`                        | Строка начинаться с ...                                                                                                                                                 |
| `$` / `строка$`            | Строка заканчивается указанными символами. (знак доллара должен быть в конце искомой строки)                                                                            |
| `a│b`                      | Или `a` или `b` (Это можно повторять сколько угодно)                                                                                                                    |
| `(Шаблон)`                 | Сгруппировать нумерованный результат                                                                                                                                    |
| `(?P<ИмяГруппы>Шаблон)`    | Сгруппировать именованный результат                                                                                                                                     |
| `(?P=ИмяГруппы)`           | Повторить условия группы по указанному имени                                                                                                                            |
| `(?:Шаблон)`               | Сгруппировать шаблон, но не добавлять его результата (нужно для обведения какого-то паттерна)                                                                           |
| `(?=Шаблон)`               | НИЖЕ                                                                                                                                                                    |
| `(?!=Шаблон)`              | НИЖЕ                                                                                                                                                                    |
| `(?<=Старт)Шаблон(?=Стоп)` | Вариант для поиска блочных элементов в тексте                                                                                                                           |

- `(?=Шаблон)` Выражение верно если текст соответствует шаблону. Сама группа не попадет в результат

    ```bash
    re.findall('Isaac\d (?=Asimov)','Isaac1 Asimov, Isaac2 other'
    >>['Isaac1']
    ```

- `(?!Шаблон)` Выражение верно если текст НЕ соответствует шаблону. Сама группа не попадет в результат

    ```bash
    re.findall('Isaac\d (?!Asimov)','Isaac1 Asimov, Isaac2 other'
    >>['Isaac2']
    ```

- `(?<=Шаблон)` Выражение верно если текст начинается на эту группу. Сама группа не попадет в результат

    ```bash
    re.findall('(?<=abc)def\d','abcdef1, bcdef2'
    >>['def1']
    ```

- `(?<!Шаблон)` Выражение верно если текст НЕ начинается яна эту группу. Сама группа не попадет в результат
    ```bash
    re.findall('(?<!abc)def\d','abcdef1, bcdef2'
    >>['def2']
    ```

---

- `(?P=<ИмяГруппы>)`

    ```bash
    re.findall('(?P<sp>a)(?P=sp)','Isaac Asimo asd')
    >>['a']
    ```

- `(?<=Старт)Шаблон(?=Стоп)`

    ```bash
    re.findall('(?<=#START#).*?(?=#END#)','Текст от #START# до #END#')
    >>['до']
    ```

- `(?<!\d)\d(?!\d)`

    ```bash
    re.findall('(?<!\d)\d(?!\d)','Text ABC 123 A1B2C3!')
    >>['1','2','3']
    ```

---

lookaround на примере королей и императоров Франции

Людовик(?=VI) — Людовик, за которым идёт VI

    КарлIV, КарлIX, КарлV, КарлVI, КарлVII, КарлVIII,
    ЛюдовикIX, ЛюдовикVI, ЛюдовикVII, ЛюдовикVIII, ЛюдовикX, ..., ЛюдовикXVIII,
    ФилиппI, ФилиппII, ФилиппIII, ФилиппIV, ФилиппV, ФилиппVI

Людовик(?!VI) — Людовик, за которым идёт не VI

    КарлIV, КарлIX, КарлV, КарлVI, КарлVII, КарлVIII,
    ЛюдовикIX, ЛюдовикVI, ЛюдовикVII, ЛюдовикVIII, ЛюдовикX, ..., ЛюдовикXVIII,
    ФилиппI, ФилиппII, ФилиппIII, ФилиппIV, ФилиппV, ФилиппVI

(?<=Людовик)VI — «шестой», но только если Людовик

    КарлIV, КарлIX, КарлV, КарлVI, КарлVII, КарлVIII,
    ЛюдовикIX, ЛюдовикVI, ЛюдовикVII, ЛюдовикVIII, ЛюдовикX, ..., ЛюдовикXVIII,
    ФилиппI, ФилиппII, ФилиппIII, ФилиппIV, ФилиппV, ФилиппVI

(?<!Людовик)VI — «шестой», но только если не Людовик

    КарлIV, КарлIX, КарлV, КарлVI, КарлVII, КарлVIII,
    ЛюдовикIX, ЛюдовикVI, ЛюдовикVII, ЛюдовикVIII, ЛюдовикX, ..., ЛюдовикXVIII,
    ФилиппI, ФилиппII, ФилиппIII, ФилиппIV, ФилиппV, ФилиппVI

---


<h2 id="Функции библиотеки `re`" class="MarkdownDRY StandardHeaders">Функции библиотеки `re`</h2>


| Функция                                                        | Описание                                                                                                       |
| -------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------- |
| re.match(`<Шаблон>, <Текст>`) ->`Match`                        | Ищет соответствие шаблона в начале текста                                                                      |
| re.search(`<Шаблон>, <Текст>`) ->`Match`                       | Ищет по всей строке, но возвращает только первое найденное совпадение.                                         |
| re.findall(`<Шаблон>, <Текст>`) ->`list`                       | Возвращает список всех найденных совпадений в тексте.                                                          |
| re.split(`<Шаблон>, <Текст>, <МаксимумРазделений=0>`) ->`list` | Эта функция разделяет строку по заданному шаблону.                                                             |
| re.sub(`<Шаблон>, <НаЧтоЗаменить> ,<Текст>`) -> `str`          | Ищет шаблон в строке и заменяет его на указанную подстроку. Если шаблон не найден, строка остается неизменной. |
| re.escape(`текст`)                                             | Экранировать текст для регулярного выражения                                                                   |


<h3 id="Операции с результатом" class="MarkdownDRY StandardHeaders">Операции с результатом</h3>


| Метод                                                   | Описание                            |
| ------------------------------------------------------- | ----------------------------------- |
| `Match`.group() -> `str`                                | Получить текст результата           |
| `Match`.group(Индекс) -> `str`                          | Получить группу по индексу          |
| `Match`.group('Имя') -> `str` / `Match`['Имя'] -> `str` | Получить группу по имени            |
| `Match`.start() -> `int`                                | Начало найденного слова             |
| `Match`.end() -> `int`                                  | Конец найденного слова              |
| `Match.span()` ->`tuple[int,int]`                       | Вернет в кортеже`.start()` `.end()` |


<h3 id="re.match()" class="MarkdownDRY StandardHeaders">re.match()</h3>


Ищет соответствие шаблона в начале текста

---

Простой пример

```python
import re


def test_match():
	data_arr = "kosta_proger@google.com"

	pattern = r"[a-z_]+"
	res = re.match(pattern, data_arr)

	print(res)
	if res:
		print(res.group())  # kosta_proger


if __name__ == '__main__':
	test_match()
```

Реальный пример

```python
import re


def test_match(arr_employee_: list[str]) -> list[str]:
	pattern = "ОAО Роги"

	res: list[str] = []
	for empl_ in arr_employee_:
		tmp = re.match(pattern, empl_)
		if tmp:
			res.append(empl_)
	return res


if __name__ == '__main__':
	arr_employee = [
			"ОAО Роги, Организационно-распорядительные, финансово-отчетные, кадровые ",
			"ОAО Роги, Приказы, договоры, инструкции, служебные записки, протоколы и т.д.",
			"ОAО Копыто, Индивидуальные, примерные, типовые",
			]

	res = test_match(arr_employee)
	print(res) # ['ОAО Роги, Организационно-распорядительные, финансово-отчетные, кадровые ', 'ОAО Роги, Приказы, договоры, инструкции, служебные записки, протоколы и т.д.']
```


<h3 id="re.search()" class="MarkdownDRY StandardHeaders">re.search()</h3>


---

Ищет по всей строке, но возвращает только первое найденное совпадение.

---

Реальный пример

```python
import re


def test_match(arr_employee_: list[tuple[str, str]]) -> list[tuple[str, str]]:
	pattern = "[Pp]ython"

	res: list[tuple[str, str]] = []
	for empl_ in arr_employee_:
		tmp = re.search(pattern, empl_[1])
		if tmp:
			res.append(empl_)
	return res


if __name__ == '__main__':
	arr_employee = [
			("Иван", "Я специалист по компьютерным наукам, знаю Python"),
			("Семен", "Я специалист по компьютерным наукам, знаю python"),
			("Костя", "Я специалист по компьютерным наукам, знаю Java"),
			]

	res = 	test_match(arr_employee)
	print(res) # [('Иван', 'Я специалист по компьютерным наукам, знаю Python'), ('Семен', 'Я специалист по компьютерным наукам, знаю python')]
```


<h3 id="re.findall()" class="MarkdownDRY StandardHeaders">re.findall()</h3>


---

Возвращает список всех найденных совпадений в тексте.

---

```python
import re


def test_match(arr_employee_: list[str]) -> list[str]:
	pattern = "ОAО Роги"

	res: list[str] = []
	for empl_ in arr_employee_:
		tmp = re.findall(pattern, empl_)
		if tmp:
			res.append(tmp)
	return res


if __name__ == '__main__':
	arr_employee = [
			"ОAО Роги, Организационно-распорядительные, ОAО Роги, финансово-отчетные, кадровые ",
			"ОAО Роги, Приказы, договоры, инструкции, служебные записки, протоколы и т.д.",
			"ОAО Копыто, Индивидуальные, примерные, типовые",
			]

	res = test_match(arr_employee)
	print(res) # [['ОAО Роги', 'ОAО Роги'], ['ОAО Роги']]
```


<h3 id="re.finditer()" class="MarkdownDRY StandardHeaders">re.finditer()</h3>


Тоже что и `re.findall`, в добавок мы получаем итератор из `Match`

```python
import re


def test_match(arr_employee_: list[str]) -> list[str]:
    pattern = "ОAО Роги"

    res: list[str] = []
    for empl_ in arr_employee_:
        for tmp in re.finditer(pattern, empl_):
            if tmp:
                res.append(tmp)
    return res


if __name__ == '__main__':
    arr_employee = [
        "ОAО Роги, Организационно-распорядительные, ОAО Роги, финансово-отчетные, кадровые ",
        "ОAО Роги, Приказы, договоры, инструкции, служебные записки, протоколы и т.д.",
        "ОAО Копыто, Индивидуальные, примерные, типовые",
    ]

    res = test_match(arr_employee)
    print(res)
    # [<re.Match object; span=(0, 8), match='ОAО Роги'>,
    # <re.Match object; span=(43, 51), match='ОAО Роги'>,
    # <re.Match object; span=(0, 8), match='ОAО Роги'>]
```


<h3 id="re.split()" class="MarkdownDRY StandardHeaders">re.split()</h3>


---

Эта функция разделяет строку по заданному шаблону.

---

```python
import re
from pprint import pprint


def test_match(arr_employee_: list[str]) -> list:
	pattern = "[@.]"

	res = []
	for empl_ in arr_employee_:
		tmp = re.split(pattern, empl_)
		if tmp:
			res.append(tmp)
	return res


if __name__ == '__main__':
	arr_mail = [
			"employee1@mail.ru",
			"employee2@tut.by",
			"employee3@yandex.ru",
			"employee1@mydomain.by",
			"employee2@mydomain.by",
			"employee3@mydomain.by",
			]

	res = test_match(arr_mail)
	pprint(res)

"""
[['employee1', 'mail', 'ru'],
 ['employee2', 'tut', 'by'],
 ['employee3', 'yandex', 'ru'],
 ['employee1', 'mydomain', 'by'],
 ['employee2', 'mydomain', 'by'],
 ['employee3', 'mydomain', 'by']]
"""
```


<h3 id="re.sub()" class="MarkdownDRY StandardHeaders">re.sub()</h3>


---

Ищет шаблон в строке и заменяет его на указанную подстроку. Если шаблон не найден, строка остается неизменной.

---

```python
import res


def test_match(arr_employee_: list[str]) -> list:
	pattern = "mail|tut|yandex|mydomain"
	repl = "google"

	res = []
	for empl_ in arr_employee_:
		tmp = re.sub(pattern,repl,empl_)
		if tmp:
			res.append(tmp)
	return res


if __name__ == '__main__':
	arr_mail = [
			"employee1@mail.ru",
			"employee2@tut.by",
			"employee3@yandex.ru",
			"employee1@mydomain.by",
			"employee2@mydomain.by",
			"employee3@mydomain.by",
			]

	res = test_match(arr_mail)
	pprint(res)

"""
['employee1@google.ru',
 'employee2@google.by',
 'employee3@google.ru',
 'employee1@google.by',
 'employee2@google.by',
 'employee3@google.by']
"""

```

---

Если вам нужно получить данные из шаблона который совпадать с `repl`. Например, нам нужно найти строку по шаблону `host:port`, но заменить нужно только `port`, мы можем использовать группировку, нужный текст шаблона заключаем в круглые скобки, а место куда эти данные нужно подставить в замене `\g<НомерГруппы>`, номер группы начинается с единицы

```python
text = "буквы буквы ыфвывфыв 127.0.0.0:8080 фв ы фы фы "
re.sub(pattern=r'(\d+.\d+.\d+.\d+:)\d{4}',repl='\g<1>_',string=text)

<h1 id="буквы буквы ыфвывфыв 127.0.0.0:_ фв ы фы фы" class="MarkdownDRY StandardHeaders">буквы буквы ыфвывфыв 127.0.0.0:_ фв ы фы фы</h1>

```

---

Если вам нужно заменить символы один к одному, а не группой. Это может быть полезно если нужно удалить ненужные символы, но при этом оставить длину текста.

```python
text = """

port = 8080
any_name = "secret_data_sd"

any_name2 = "secret_data"

def ini(se):
	a = 10
	print(se)
"""

re.sub(r"""['"]{1}[\w\d\s_.,/'#$:=\[\]\(\)\{\}]+['"]{1}|['"]{3}[\w\d\s_.,/'"#$:=\[\]\(\)\{\}]+['"]{3}""",
	   lambda m: "#" * len(m.group()),
	   __text_conf)

"""
port = 8080
any_name = #############

any_name = #############

def ini(se):
	a = 10
	print(se)
"""
```


<h3 id="Группировка результата" class="MarkdownDRY StandardHeaders">Группировка результата</h3>


```python
import re
from pprint import pprint


def test_match(arr_employee_: list[str]) -> list:
	pattern = "([a-z0-9]+)@([a-z]+)"
	repl = "google"

	res = []
	for empl_ in arr_employee_:
		tmp = re.search(pattern, empl_)
		if tmp:
			res.append((tmp.group(1), tmp.group(2)))
	return res


if __name__ == '__main__':
	arr_mail = [
			"employee1@mail.ru",
			"employee2@tut.by",
			"employee3@yandex.ru",
			"employee1@mydomain.by",
			"employee2@mydomain.by",
			"employee3@mydomain.by",
			]

	res = test_match(arr_mail)
	pprint(res)

"""
[('employee1', 'mail'),
 ('employee2', 'tut'),
 ('employee3', 'yandex'),
 ('employee1', 'mydomain'),
 ('employee2', 'mydomain'),
 ('employee3', 'mydomain')]
"""
```


<h2 id="Примеры" class="MarkdownDRY StandardHeaders">Примеры</h2>


- Найти весь текст от `Старт` до `Стоп`

    Шаблон

    ```re
    (?<=Старт)\s+(?:.\s*(?!Стоп))+[\w\W]
    ```

    ```re
    (?<=select)\s+(?:.\s*(?!from))+[\w\W]

    select((?<=select)\s+(?:.\s*(?!from))+[\w\W])from((?<=from)\s+(?:.\s*(?!where))+[\w\W])where[^*]+
    ```

    ```sql
    SELECT stat1.Name, stat1.Orders,(select * from treat ), stat1.Date, stat2.Orders, stat2.Date FROM
    (SELECT statistics.ProductID, products.Name, statistics.Orders, statistics.Date
    FROM products JOIN statistics ON products.id = statistics.ProductID WHERE
    DATE(statistics.date) = '2014-09-04') AS stat1 JOIN (SELECT statistics.ProductID,
    statistics.Orders, statistics.Date FROM statistics WHERE DATE(statistics.date) =
    '2014-09-12') AS stat2 ON stat1.ProductID = stat2.ProductID


    select tat1.Name, stat1.Orders,
     stat1.Date
    from treat

    join treat

    group by taul.name, stat.Orders
    order by name
    ```

- Поиск самого вложенной скобки
    https://stackoverflow.com/questions/133601/can-regular-expressions-be-used-to-match-nested-patterns

    ```re
    # Последняя вложеная скобка
    (?:\((?:([^\(\)]*))\))

    # Получить все что есть в скобках с учетом вложености (нужна библиотека regex)
    \((?:[^()]+|(?R))*\)

    # Прошлый варинат
    (?:(?:[(])(?:[^()]*))+(?:(?:[)])(?:[^()]*))+\)
    ```

    ```sql
    hbdtn(
    	ghbdtn (
    		ghbdtn (
    			gjrf(
    				hrfrfrf
    			)
    			gjrf(
    				hrfrfrff(
    					hrfrfrf
    				)
    			)
    			gjrf(
    				hrfrfrf
    			)
    			asdasdasd
    		) asdasd
    	) sadad
    )
    SELECT
    	stat1.Name, stat1.Orders,(select * from (
    	select
    	- date(12,3213)
    	from tret
    	) treat)stat1.Date, stat2.Orders, stat2.Date FROM
    	(SELECT statistics.ProductID, products.Name, statistics.Orders, statistics.Date     FROM products JOIN statistics ON products.id = statistics.ProductID WHERE

    	DATE(statistics.date) = '2014-09-04'
    	DATE(statistics.date) = '2014-09-04'

    ) AS stat1 JOIN (SELECT statistics.ProductID,
    	statistics.Orders, statistics.Date FROM statistics WHERE DATE(statistics.date) =
    	'2014-09-12') AS stat2 ON stat1.ProductID = stat2.ProductID


    	select tat1.Name, stat1.Orders,
    	 stat1.Date
    	from treat

    	join treat

    	group by taul.name, stat.Orders
    	order by name
    ```

- Найти слова, которые повторяются

    ```re
    (?P<name>.+)(?P=name)
    ```

    ```python
    hbdtn(
      ghbdtn (
    	 ghbdtn (
    		gjrf(
    		   hrfrfrf
    		   )
     asdasdasd
    	  )
      asdasd
       )
      sadad
    )


    SELECTSELECT
    ```


<h3 id="Форматирование SQL" class="MarkdownDRY StandardHeaders">Форматирование SQL</h3>


```sql
select distinct
    sd.sdid,
    sj.stathistnum,
    (
        select max(gp.sprice) from  treatplace tp
        LEFT join paramsinfo p on tp.protocolid = p.protocolid and p.ver_no = 0 and p.codeparams = 10010423 /*ксг*/
        LEFT join wschema w on p.valueint = w.schid
        left join get_pricebyid(p.treatdate,10000298,1,0,0,w.schid) gp on 1=1
        where sd.sdid = tp.dirid
    ) ksg,
    sdep.sdepname,
    c.fullname,
    coalesce(d.fullname, 'Не указан') dname,
    sd.planstart,
    sd.planend,
    bedday.daycount,
    iif(coalesce(sj.dayhospital,0) = 1, 0, 1) stat,
    iif((select ageinyears from getage(c.bdate,cast(sd.planstart as date))) >= 18,1,0) adult,
    iif((select ageinyears from getage(c.bdate,cast(sd.planstart as date))) < 18,1,0) child,
    iif((select ageinyears from getage(c.bdate,cast(sd.planstart as date))) >= 18,bedday.daycount,0) daycount_adult,
    iif((select ageinyears from getage(c.bdate,cast(sd.planstart as date))) < 18,bedday.daycount,0) daycount_child,
    (
        select SUM(coalesce(od.schamount_a,0)) amount
        from clreferrals clr
        join clrefdet cld on clr.refid = cld.refid and coalesce(cld.nazdelete,0) = 0 and coalesce(cld.nalkateg,0) = 0
        join wschema w on cld.schid = w.schid
        left join treatsch tsc on cld.tschid = tsc.tschid
        left join treat t on t.treatcode = tsc.treatcode
        left join orderdet od on tsc.schnum = od.schnum and t.orderno = od.orderno
        where clr.dirid = SD.SDID and clr.reftype = 10000490
    ) MEDIC_AMOUNT,
    cast(fzp.pet_metion as integer) pet_metion,
    cast(fzp.pet_gluk as integer) pet_gluk,
    cast(fzp.kt_cont as integer) kt_cont,
    cast(fzp.mrt_cont as integer) mrt_cont,
    cast(fzp.obsl_pet as integer) obsl_pet,
    cast(fzp.obsl_mrt as integer) obsl_mrt,
    cast(fzp.obsl_kt as integer) obsl_kt,
    cast(fzp.medical_anest as integer) medical_anest,
    cast(fzp.vn_lab as integer) vn_lab,
    cast(fzp.gr_blood as integer) gr_blood,
    cast(fzp.gisto as integer) gisto,
    cast(fzp.ekg as integer) ekg,
    cast(fzp.eeg as integer) eeg,
    cast(fzp.uzgd as integer) uzgd,
    cast(fzp.moigramma as integer) moigramma,
    cast(fzp.rentgen as integer) rentgen,
    cast(fzp.okylist as integer) okylist,
    iif(fzp.okylist_dname <> '', 'Окулист: ' ||  fzp.okylist_dname, '') || iif(fzp.terap_dname <> '', ' Терапевт/педиатр: ' ||  fzp.terap_dname, '') || iif(fzp.logoped_dname <> '', ' Логопед: ' ||  fzp.logoped_dname, '') || iif(fzp.cons_lfk_dname <> '', ' ЛФК: ' ||  fzp.cons_lfk_dname, '') || iif(fzp.fizioterap_dname <> '', ' Физиотерапевт: ' ||  fzp.fizioterap_dname, '') || iif(fzp.nevr_dname <> '', ' Невролог: ' ||  fzp.nevr_dname, '') || iif(fzp.neirohir_dname <> '', ' Нейрохирург: ' ||  fzp.neirohir_dname, '') || iif(fzp.psih_dname <> '', ' Психиатр: ' ||  fzp.psih_dname, '') || iif(fzp.specialist_dname <> '', ' Специалист: ' ||  fzp.specialist_dname, '') spec_all_name,
    cast(fzp.terap as integer) terap,
    fzp.terap_dname,
    cast(fzp.logoped as integer) logoped,
    fzp.logoped_dname,
    cast(fzp.cons_lfk as integer) cons_lfk,
    fzp.cons_lfk_dname,
    cast(fzp.fizioterap as integer) fizioterap,
    fzp.fizioterap_dname,
    cast(fzp.nevr as integer) nevr,
    fzp.nevr_dname,
    cast(fzp.neirohir as integer) neirohir,
    fzp.neirohir_dname,
    cast(fzp.psih as integer) psih,
    fzp.psih_dname,
    cast(fzp.specialist as integer) specialist,
    fzp.specialist_dname,
    fzp.lfk,
    fzp.fizio,
    fzp.massage,
    cast(fzp.kt_without_cont as integer) kt_without_cont,
    cast(fzp.kt_with_cont as integer) kt_with_cont,
    cast(fzp.kt_without_cont_child as integer) kt_without_cont_child,
    cast(fzp.pet_fzp as integer) pet_fzp,
    cast(fzp.anest as integer) anest,
    cast(fzp.video_night as integer) video_night,
    cast(fzp.video_12 as integer) video_12,
    cast(fzp.video_24 as integer) video_24,
    cast(fzp.video_36 as integer) video_36,
    cast(fzp.video_4 as integer) video_4,
    (select distinct 1 as lab from treat t join treatsch tsc on t.treatcode = tsc.treatcode and coalesce(tsc.nalkateg,0) = 0 join wschema w on tsc.schid = w.schid and w.speccode = 10000126 where t.dirid = sd.sdid) lab,
    cast(mrt_fzp.mrt_without_contr as integer) mrt_without_contr,
    cast(mrt_fzp.mrt_with_contr as integer) mrt_with_contr,
    cast(mrt_fzp.mrt_without_contr_child as integer) mrt_without_contr_child,
    cast(mrt_fzp.mrt_with_contr_child as integer) mrt_with_contr_child
from stat_direction sd
join stat_jornal sj on sd.sdid = sj.dirid
join stat_departments sdep on sd.stat_dep = sdep.sdepid
join clients c on sd.pcode = c.pcode
left join doctor d on sj.dcode = d.dcode
left join STAT_BEDDAYCOUNT(sD.PLANSTART, sd.planend, Iif(sD.DSTATUS in (2, 6, 8), -1, 0), sd.sdid, sD.STAT_DEP, sJ.DAYHOSPITAL) bedday on 1=1
join jpagreement jpa on sd.agrid = jpa.agrid
join jpagrtypes jpt on jpt.omsagr = 1 and jpa.agrtype = jpt.agrtype
left join (
    select DISTINCT SD2.SDID dirid,
    count(distinct iif(d.dicname containing 'ПЭТ метионин', t.treatcode, null)) pet_metion,
    count(distinct iif(d.dicname containing 'ПЭТ глюкоза', t.treatcode, null)) pet_gluk,
    count(distinct iif(d.dicname containing 'КТ с контрастом', t.treatcode, null)) kt_cont,
    count(distinct iif(d.dicname containing 'МРТ с контрастом', t.treatcode, null)) mrt_cont,
    sum(iif(d.dicname in ('ПЭТ метионин','ПЭТ глюкоза'), tsc.scount, 0)) obsl_pet,
    sum(iif(d.dicname in ('МРТ с контрастом','МРТ без контраста'), tsc.scount, 0)) obsl_mrt,
    sum(iif(d.dicname in ('КТ с контрастом','КТ без контраста'), tsc.scount, 0)) obsl_kt,
    sum(iif(w.kodoper in ('A11.12.003.010', 'A11.12.003.011'),tsc.scount,0)) medical_anest,
    sum(iif(w.kodoper in ('ВнАн01'),tsc.scount,0)) vn_lab,
    sum(iif(w.kodoper in ('ВнАн02'),tsc.scount,0)) gr_blood,
    sum(iif(w.kodoper in ('ВнАн03'),tsc.scount,0)) gisto,
    sum(iif(d.dicname containing 'ЭКГ', tsc.scount, 0)) ekg,
    sum(iif(d.dicname containing 'ЭЭГ', tsc.scount, 0)) eeg,
    sum(iif(d.dicname containing 'УЗДГ', tsc.scount, 0)) uzgd,
    sum(iif(d.dicname containing 'Миограмма', tsc.scount, 0)) moigramma,
    sum(iif(d.dicname containing 'Рентген', tsc.scount, 0)) rentgen,
    sum(iif(d.dicname containing 'Окулист', tsc.scount, 0)) okylist,
    list(iif(d.dicname containing 'Окулист', doct.dname, null)) okylist_dname,
    sum(iif(d.dicname containing 'Терапевт/педиатр', tsc.scount, 0)) terap,
    list(iif(d.dicname containing 'Терапевт/педиатр', doct.dname, null)) terap_dname,
    sum(iif(d.dicname containing 'Логопед', tsc.scount, 0)) logoped,
    list(iif(d.dicname containing 'Логопед', doct.dname, null)) logoped_dname,
    sum(iif(d.dicname containing 'Консультация ЛФК', tsc.scount, 0)) cons_lfk,
    list(iif(d.dicname containing 'Консультация ЛФК', doct.dname, null)) cons_lfk_dname,
    sum(iif(d.dicname containing 'Физиотерапевт', tsc.scount, 0)) fizioterap,
    list(iif(d.dicname containing 'Физиотерапевт', doct.dname, null)) fizioterap_dname,
    sum(iif(d.dicname containing 'Невролог', tsc.scount, 0)) nevr,
    list(iif(d.dicname containing 'Невролог', doct.dname, null)) nevr_dname,
    sum(iif(d.dicname containing 'Нейрохирург', tsc.scount, 0)) neirohir,
    list(iif(d.dicname containing 'Нейрохирург', doct.dname, null)) neirohir_dname,
    sum(iif(d.dicname containing 'Психиатр', tsc.scount, 0)) psih,
    list(iif(d.dicname containing 'Психиатр', doct.dname, null)) psih_dname,
    sum(iif(d.dicname containing 'Специалист', tsc.scount, 0)) specialist,
    list(iif(d.dicname containing 'Специалист', doct.dname, null)) specialist_dname,
    sum(iif(d.dicname containing 'ЛФК', tsc.scount * iif((select ageinyears from getage(c.bdate,cast(sd2.planstart as date))) < 18, w.uet2, w.uet1), 0)) lfk,
    sum(iif(d.dicname containing 'Физиотерапия', tsc.scount * iif((select ageinyears from getage(c.bdate,cast(sd2.planstart as date))) < 18, w.uet2, w.uet1), 0)) fizio,
    sum(iif(d.dicname containing 'Массаж', tsc.scount * iif((select ageinyears from getage(c.bdate,cast(sd2.planstart as date))) < 18, w.uet2, w.uet1), 0)) massage,
    sum(iif(d.dicname containing 'КТ без контраста' and (select ageinyears from getage(c.bdate,cast(sd2.planstart as date))) >= 18, tsc.scount, 0)) kt_without_cont,
    sum(iif(d.dicname containing 'КТ с контрастом' and (select ageinyears from getage(c.bdate,cast(sd2.planstart as date))) >= 18, tsc.scount, 0)) kt_with_cont,
    sum(iif(d.dicname containing 'КТ без контраста' and (select ageinyears from getage(c.bdate,cast(sd2.planstart as date))) < 18, tsc.scount, 0)) kt_without_cont_child,
    sum(iif(d.dicname in ('ПЭТ метионин','ПЭТ глюкоза'), tsc.scount, 0)) pet_fzp,
    sum(iif(d.dicname containing 'Анестезиология', tsc.scount, 0)) anest,
    sum(iif(d.dicname containing 'Видеомониторинг ночной', tsc.scount, 0)) video_night,
    sum(iif(d.dicname containing 'Видеомониторинг 12', tsc.scount, 0)) video_12,
    sum(iif(d.dicname containing 'Видеомониторинг 24', tsc.scount, 0)) video_24,
    sum(iif(d.dicname containing 'Видеомониторинг 36', tsc.scount, 0)) video_36,
    sum(iif(d.dicname containing 'Видеомониторинг 4', tsc.scount, 0)) video_4
    from TREAT T
    JOIN STAT_direction sd2 on t.dirid = sd2.sdid
    join clients c on t.pcode = c.pcode
    join treatsch tsc on t.treatcode = tsc.treatcode  and coalesce(tsc.cancuid,0) = 0
    join wschema w on tsc.schid = w.schid
    join doctor doct on t.dcode = doct.dcode
    left join recpropvalues rpv on w.schid = rpv.recid and rpv.recpropid = 10000078
    left join recpropvaluetype rpvt on rpv.recpropvaltypeid =  rpvt.recpropvaltypeid
    left join dicinfo d on rpvt.dicrefid = d.refid and rpv.propvalueint = d.dicid
    where cast(sd2.planend as date) between '[bdate]' and '[fdate]' and sd2.dstatus in (4,7)
    group by 1
    ) fzp on fzp.dirid = sd.sdid
left join (
    select dirid,
    sum(mrt_without_contr) mrt_without_contr,
    sum(mrt_with_contr) mrt_with_contr,
    sum(mrt_without_contr_child) mrt_without_contr_child,
    sum(mrt_with_contr_child) mrt_with_contr_child
    from
    (select t.dirid,
    sum(iif(d.dicname containing 'МРТ без контраста' and (select ageinyears from getage(c.bdate,cast(sd.planstart as date))) >= 18, tsc.scount, 0)) mrt_without_contr,
    sum(iif(d.dicname containing 'МРТ с контрастом' and (select ageinyears from getage(c.bdate,cast(sd.planstart as date))) >= 18, tsc.scount, 0)) mrt_with_contr,
    sum(iif(d.dicname containing 'МРТ без контраста' and (select ageinyears from getage(c.bdate,cast(sd.planstart as date))) < 18, tsc.scount, 0)) mrt_without_contr_child,
    sum(iif(d.dicname containing 'МРТ с контрастом' and (select ageinyears from getage(c.bdate,cast(sd.planstart as date))) < 18, tsc.scount, 0)) mrt_with_contr_child
    from TREAT T
    JOIN STAT_direction sd on t.dirid = sd.sdid
    join clients c on t.pcode = c.pcode
    join treatsch tsc on t.treatcode = tsc.treatcode  and coalesce(tsc.cancuid,0) = 0
    join wschema w on tsc.schid = w.schid
    left join recpropvalues rpv on w.schid = rpv.recid and rpv.recpropid = 10000078
    left join recpropvaluetype rpvt on rpv.recpropvaltypeid =  rpvt.recpropvaltypeid
    left join dicinfo d on rpvt.dicrefid = d.refid and rpv.propvalueint = d.dicid
    where cast(sd.planend as date) between '[bdate]' and '[fdate]' and sd.dstatus in (4,7) and not exists (select tsc2.tschid from treatsch tsc2 join wschema w2 on tsc2.schid = w2.schid where tsc2.treatcode = t.treatcode and w2.kodoper in ('A05.30.018','A05.30.019')) /* сначала берем приемы без услуг введения препарата */
    group by 1
    union all
    select t.dirid,
    (sum(iif((select ageinyears from getage(c.bdate,cast(sd.planstart as date))) >= 18 and w.kodoper not in ('A05.30.018',  'A05.30.019', 'A06.30.002.008', 'A06.30.002.012', 'A06.30.002.013'), tsc.scount, 0)) - count(distinct iif((select ageinyears from getage(c.bdate,cast(sd.planstart as date))) >= 18, t.treatcode, null))) mrt_without_contr,
    count(distinct iif((select ageinyears from getage(c.bdate,cast(sd.planstart as date))) >= 18, t.treatcode, null)) mrt_with_contr,
    (sum(iif((select ageinyears from getage(c.bdate,cast(sd.planstart as date))) < 18 and w.kodoper not in ('A05.30.018',  'A05.30.019', 'A06.30.002.008', 'A06.30.002.012', 'A06.30.002.013'), tsc.scount, 0)) - count(distinct iif((select ageinyears from getage(c.bdate,cast(sd.planstart as date))) < 18, t.treatcode, null))) mrt_without_contr_child,
    count(distinct iif((select ageinyears from getage(c.bdate,cast(sd.planstart as date))) < 18, t.treatcode, null)) mrt_with_contr_child
    from TREAT T
    JOIN STAT_direction sd on t.dirid = sd.sdid
    join clients c on t.pcode = c.pcode
    join treatsch tsc on t.treatcode = tsc.treatcode  and coalesce(tsc.cancuid,0) = 0 join wschema w on tsc.schid = w.schid
    where cast(sd.planend as date) between '[bdate]' and '[fdate]' and sd.dstatus in (4,7) and exists (select tsc2.tschid from treatsch tsc2 join wschema w2 on tsc2.schid = w2.schid where tsc2.treatcode = t.treatcode and w2.kodoper in ('A05.30.018','A05.30.019')) /* потом берем приемы без услуг введения препарата */
    group by 1)
    group by 1
    ) mrt_fzp on mrt_fzp.dirid = sd.sdid
where
    cast(sd.planend as date) between '[bdate]' and '[fdate]'
    and sd.dstatus in (4,7)
    and (sdep.sdepid = iif([stat_dep] = -1,sdep.sdepid,[stat_dep]))
ORDER BY sdep.sdepname, sj.stathistnum
```


<h1 id="Тестирование" class="MarkdownDRY StandardHeaders">Тестирование</h1>


Самый главный смысл тестирование кода, заключается в проверки работоспособности программы при её частом изменении. Если ваша программа ни когда не измениться, то вам не нужны тесты, вы можете один раз самостоятельно протестировать программу и на этом тестирование закончиться, вам не нужно писать для этого тестов, но вряд ли существуют такие программы которые ни когда не изменяются. Все успешные программы развиваются и эволюционируют, их исходный код постоянно изменяется и дорабатывается, и в этом случае каждый раз производить тестирование в ручную это большая затрата времени, в итоги когда ваша программа будет настолько большой, что изменение одно части программы, не известно как повлияют на другую часть этой программы. Для этого и нужны тесты - чтобы удостовериться, что ваша программа работает после доработок и изменений, по крайне мере она выполняет те требования которые проверяются в тестирование.

- Хорошей привычкой в тестирование является фиксация сценариев при которых произошли баги в программе.
- В тестирование программы не нужно заботиться о производительности.


<h2 id="`UnitTest`" class="MarkdownDRY StandardHeaders">`UnitTest`</h2>


Смысл `unit-test` заключается в тестирование каждой функции и метода, по отдельности. Также `unit-test` используют для воссоздания сценариев работы. [Документация UnitTest](https://docs.python.org/3/library/unittest.html)

---

Особенности:

- Обычно все тесты программ хранят в папке `test`. Это удобно, потому что тогда можно запустить все тесты сразу (последовательно).
- Имя файлов, имя методов, имя директории = должны начинаться со слова `test`.
- Создать сценарий запуска всех тестов в папке. Выберете общую папку с тестами `test`. ![Создать сценарий запуска всех тестов в папке](_attachments/be047a1af9385ab74a924cb9a7f4abc5.png)

---

- Проект
    - test (Общая папка с тестами)
        - test_name1.py
        - test_name2.py
    - main.py

```python
import unittest
class Test_<Name>(unittest.TestCase):

	def setUp(self): # Выполнятся перед вызовом каждого метода
		...

	def test_<NameMethed>(self): # Все методы должны начинатся с слова `test_`
		...

	def tearDown(self): # Выполнятся после **успешного** выполенния каждого теста
		...

	def __del__(self): # Деструктор класса
		...

if __name__ == '__main__':
	unittest.main() # Запустить все тесты
```

---

| Метод                                           | Пример из `Python`                                                                              |
| ----------------------------------------------- | ----------------------------------------------------------------------------------------------- |
| assertEqual(a, b)                               | a == b                                                                                          |
| assertNotEqual(a, b)                            | a != b                                                                                          |
| assertTrue(x)                                   | bool(x) is True                                                                                 |
| assertFalse(x)                                  | bool(x) is False                                                                                |
| assertIs(a, b)                                  | a is b                                                                                          |
| assertIsNot(a, b)                               | a is not b                                                                                      |
| assertIsNone(x)                                 | x is None                                                                                       |
| assertIsNotNone(x)                              | x is not None                                                                                   |
| assertIn(a, b)                                  | a in b                                                                                          |
| assertNotIn(a, b)                               | a not in b                                                                                      |
| assertIsInstance(a, b)                          | isinstance(a, b)                                                                                |
| assertNotIsInstance(a, b)                       | not isinstance(a, b)                                                                            |
| ---                                             | ---                                                                                             |
| assertRaises(`exc, fun, *args, **kwds`)         | fun(`*args, **kwds`) порождает исключение exc                                                   |
| assertRaisesRegex(`exc, r, fun, *args, **kwds`) | fun(`*args, **kwds`) порождает исключение exc и сообщение соответствует регулярному выражению r |
| assertWarns(`warn, fun, *args, **kwds`)         | fun(`*args, **kwds`) порождает предупреждение                                                   |
| assertWarnsRegex(`warn, r, fun, *args, **kwds`) | fun(`*args, **kwds`) порождает предупреждение и сообщение соответствует регулярному выражению r |
| ---                                             | ---                                                                                             |
| assertAlmostEqual(a, b)                         | round(a-b, 7) == 0                                                                              |
| assertNotAlmostEqual(a, b)                      | round(a-b, 7) != 0                                                                              |
| assertGreater(a, b)                             | a > b                                                                                           |
| assertGreaterEqual(a, b)                        | a >= b                                                                                          |
| assertLess(a, b)                                | a < b                                                                                           |
| assertLessEqual(a, b)                           | a <= b                                                                                          |
| assertRegex(s, r)                               | r.search(s)                                                                                     |
| assertNotRegex(s, r)                            | not r.search(s)                                                                                 |
| assertCountEqual(a, b)                          | a и b содержат те же элементы в одинаковых количествах, но порядок не важен                     |
| ---                                             | ---                                                                                             |
| assertMultiLineEqual(a, b)                      | строки (strings)                                                                                |
| assertSequenceEqual(a, b)                       | последовательности (sequences)                                                                  |
| assertListEqual(a, b)                           | списки (lists)                                                                                  |
| assertTupleEqual(a, b)                          | кортежи (tuplse)                                                                                |
| assertSetEqual(a, b)                            | множества или неизменяемые множества (frozensets)                                               |
| assertDictEqual(a, b)                           | словари (dicts)                                                                                 |

---

Декораторы `UnitTest`

- `@unittest.skip("<Уведомление>")` = Пропустить метод
- `@unittest.skipIf(<Условие>, "<Уведомление>")` = Пропустить метод если условие верно
- `@unittest.skipUnless(<Условие>, "<Уведомление>")` = Пропустить метод если условие НЕ верно

---

Проверка того что должно возникнуть исключение `<ИмяОшибки>` в теле `with`

```python
with self.assertRaises(<ИмяОшибки>):
	... # Except == True

```

---


<h2 id="`DocTest`" class="MarkdownDRY StandardHeaders">`DocTest`</h2>


Смысл `docttest` завключается в тетсирование небольших независемых функция и методов.

[+](https://digitology.tech/docs/python_3/library/doctest.html)

[Документация `DocTest`](https://docs.python.org/3/library/doctest.html)

```python
import doctest


def dele(a, b):
	"""
	Sum
	:param a:
	:param b:

	>>> dele(1,2)
	3
	>>> dele(5,5)
	11
	>>> dele(5,0)
	Traceback (most recent call last):
	ZeroDivisionError
	"""
	return a / b


if __name__ == '__main__':
	doctest.testmod()
```

```bush
**********************************************************************
File "/home/denis/.config/JetBrains/PyCharm2020.1/scratches/scratch_10.py", line 13, in __main__.sum
Failed example:
    sum(5,5)
Expected:
    11
Got:
    10
**********************************************************************
1 items had failures:
   1 of   2 in __main__.sum
***Test Failed*** 1 failures.
```

Добавить `DocTest` в `UnitTest`

```python
import doctest
import types
import unittest


import ВАШ_МОДУЛЬ


class TestDoc(unittest.TestCase):
    """
    Протестировать документацию у модулей
    """
    #: Список модулей
    list_mod: tuple[types.ModuleType] = (
        ВАШ_МОДУЛЬ,
    )

    def setUp(self):
		...

    def test_docs_from_module(self):
        """

        :param mod: Список модулей
        """
        for _m in TestDoc.list_mod:
            # Выполняем док тесты
            self.assertEqual(doctest.testmod(_m).failed, 0)


if __name__ == '__main__':
    unittest.main()
```


<h2 id="`Pytest`" class="MarkdownDRY StandardHeaders">`Pytest`</h2>


[Документация](https://pytest-docs-ru.readthedocs.io/ru/latest/contents.html#toc)

---

Установка:

```bash
pip install pytest
```

---

- Запустить папку с тестами:

    ```bash
    pytest <ИмяПапки_С_Тестами/Файл_С_Тестами>
    ```

- Добавить сценарий запуск тестов в `Pycharm`
    ![Добавить сценарий запуск тестов в `Pycharm`](_attachments/3ae0c7337e5c1afc261fc083a6e4a162.png)

---

```python
import pytest

class Test_$Name$:

	def setup(self): # Выполнятся перед вызовом каждого метода
		...

	@pytest.mark.parametrize((),
							[

							])
	def test_$NameMethed$(self): # Все методы должны начинаться со слова `test_`
		...

	def teardown(self): # Выполнятся после **успешного** выполнения каждого теста
		...

	def __del__(self): # Деструктор класса
		...
```

---

Для того чтобы создать тест, нам необходимо создать функцию, начинающуюся с `test_`, и уже в ней создавать `assert`

```python
import pytest

def delimeter(a, b):
	return a / b


<h1 id="Картеж с именами аргументов, массив со значениями для аргументов" class="MarkdownDRY StandardHeaders">Картеж с именами аргументов, массив со значениями для аргументов</h1>

@pytest.mark.parametrize(("a", "b", "res"), [
		(10, 2, 5),
		(20, 2, 10),
		(12, 2, 6),
		(10, 2, 5),
		])
def test_r(a, b, res):
	assert delimeter(a, b) == float(res),  "Сообщение об ошибки"




<h1 id="Ожидать возникновение ошибки" class="MarkdownDRY StandardHeaders">Ожидать возникновение ошибки</h1>

@pytest.mark.parametrize(("a", "b", "exception__"), [
		(10, 0, ZeroDivisionError),
		(20, '2', TypeError),
		])
def test_zero(a, b, exception__):
	# В контексте должна возникнуть указанная ошибка
	with pytest.raises(exception__, match="Регулярный Шаблон Для Верного Текста Исключения"):
		delimeter(a, b)




<h1 id="Пропустить весь тест" class="MarkdownDRY StandardHeaders">Пропустить весь тест</h1>

@pytest.mark.skip(reason="Пропуск теста")
def test_skip():
	assert True == False


<h1 id="Пропустить тест в теле функции" class="MarkdownDRY StandardHeaders">Пропустить тест в теле функции</h1>

def test_skip_context():
	if 1/1 == 0:
		pytest.skip("Пропустить тест из тела функции")
	assert True == False
```


<h2 id="Проект для тестирования" class="MarkdownDRY StandardHeaders">Проект для тестирования</h2>


https://github.com/denisxab/testfull_pack.git


<h1 id="Логирование - `loguru`" class="MarkdownDRY StandardHeaders">Логирование - `loguru`</h1>


Установка:

```bash
pip install loguru
```


<h2 id="Настройка логирования" class="MarkdownDRY StandardHeaders">Настройка логирования</h2>


Создать настройки для функции логирования

```python
logger.add(
	<ПутьКФайлу.log>,
	format='<ФорматВывода>',
	level='<МинимальныйУровеньСеррьезности>',

	# Необязательные агрументы
	rotation='100 KB',
	compression='zip',
)
```

- `level=''` Указать минимальный уровень срабатывание логиера
- `rotation=''` Указать размер при котром файл будет вызвать `compression`(компрессию), по умолчанию когда файл превысит указанный размер то создаться новый файл, но также можно установить сжатие файлов в аргументе `compression`. Пример размера (50 KB/ 100 MB / 1.1 GB)
- `compression=''` Формат сжатие файла (`zip`/`tar`/`gz`). Рекомендую `zip`
- `serialize='True'` Серелизовать данные в формат `Json`

- `sink` (`файлоподобный объект, str, pathlib.Path, callable, coroutine function или logging.Handler`) - Объект, отвечающий за прием форматированных сообщений протоколирования и передачу их в соответствующую конечную точку.

- `level` (`int или str, необязательно`) - Минимальный уровень серьезности, с которого сообщения журнала должны отправляться на поглотитель.

- `format` (`str или callable, необязательно`) - Шаблон, используемый для форматирования сообщений журнала перед отправкой на поглотитель.

- `filter` (`callable, str или dict, необязательно`) - Директива, которая опционально используется для решения для каждого зарегистрированного сообщения, должно ли оно быть отправлено на поглотитель или нет.

- `colorize` (`bool, опционально`) - Следует ли преобразовывать цветовые метки, содержащиеся в форматированном сообщении, в коды ansi для раскраски терминала, или отменить их. Если None, выбор будет сделан автоматически на основе того, является ли терминал tty или нет.

- `serialize` (`bool, опционально`) - Следует ли сначала преобразовать зарегистрированное сообщение и его записи в строку JSON перед отправкой на поглотитель.

- `backtrace` (`bool, опционально`) - Должна ли трассировка исключения быть расширена вверх, за пределы точки перехвата, чтобы показать полную трассировку стека, которая породила ошибку.

- `diagnose` (`bool, необязательный`) - Должна ли трассировка исключений отображать значения переменных для облегчения отладки. В производственных условиях это значение должно быть равно False, чтобы избежать утечки конфиденциальных данных.

- `enqueue` (`bool, опционально`) - Должны ли регистрируемые сообщения сначала проходить через многопроцессную очередь, прежде чем попасть в сток. Это полезно при записи в файл через несколько процессов. Преимущество этого параметра заключается также в том, что вызовы протоколирования становятся неблокирующими.

- `catch` (`bool, опционально`) - Следует ли автоматически перехватывать ошибки, возникающие во время обработки сообщений журнала поглотителем. Если True, сообщение об исключении выводится на sys.stderr, но исключение не передается вызывающей стороне, что предотвращает крах вашего приложения.

---

**Формат вывода**

| Ключевое слово | Описание                                                                                                                     |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------- |
| elapsed        | Сколько времени прошло с момента запуска программы                                                                           |
| exception      | Текст возникшего исключения                                                                                                  |
| extra          | (!)                                                                                                                          |
| file           | Файл, в котором вызвана функция логирования                                                                                  |
| function       | Функция, в котором вызвана функция логирования                                                                               |
| level          | Уровень серьезности,                                                                                                         |
| line           | Номер строки в исходном коде                                                                                                 |
| message        | Сообщение                                                                                                                    |
| module         | Имя модуля в котором вызвана функция логирования                                                                             |
| name           | Значение `__name__`                                                                                                          |
| process        | PID Процесса                                                                                                                 |
| thread         | ID Потока                                                                                                                    |
| time           | Время. (Для указания Московского часового пояса в `Djnago` установите `Name_proj->settings.py->TIME_ZONE = 'Europe/Moscow'`) |

> Рекомендую шаблон `format="{time:YYYY-MM-DD-HH:mm:ss}‡{message}‡{file}‡{function}‡{level}‡{line}‡{exception}‡"`

---

**Уровни серьезности**

| Уровень  | Значение | Метод для                                 |
| -------- | -------- | ----------------------------------------- |
| TRACE    | 5        | logger.trace(`<Сообщение>`)               |
| DEBUG    | 10       | logger.debug(`<Сообщение>`)               |
| INFO     | 20       | logger.info(`<Сообщение>`)                |
| SUCCESS  | 25       | logger.success(`<Сообщение>`)             |
| WARNING  | 30       | logger.warning(`<Сообщение>`)             |
| ERROR    | 40       | logger.error(`<Сообщение>`) `<Сообщение>` |
| CRITICAL | 50       | logger.critical(`<Сообщение>`)            |

---

Пример работы:

```python
from loguru import logger

if __name__ == '__main__':
	logger.add("fd/FileName.log", format="""
	1 ) {elapsed},
	2 ) {exception},
	3 ) {extra},
	4 ) {file},
	5 ) {function},
	6 ) {level},
	7 ) {line},
	8 ) {message},
	9 ) {module},
	10) {name},
	11) {process},
	12) {thread},
	13) {time},
	""", level="INFO",
	           rotation='10 KB',
	           compression='zip',
	           )


	for x in range(100):
		logger.error("Hello")
```


<h2 id="Декораторы логирования" class="MarkdownDRY StandardHeaders">Декораторы логирования</h2>


- `@logger.catch` = Декоратор, который ожидает исключения в функции/методе. И если они возникают то вызваться `logger.error()`.(+ красиво и информативно оформляет место в котором возникло исключение)

    ```python
    from loguru import logger

    if __name__ == '__main__':
    	logger.add("fd/FileName.log", format="""
    	1 ) {elapsed},
    	2 ) {exception},
    	3 ) {extra},
    	4 ) {file},
    	5 ) {function},
    	6 ) {level},
    	7 ) {line},
    	8 ) {message},
    	9 ) {module},
    	10) {name},
    	11) {process},
    	12) {thread},
    	13) {time},
    	""", level="INFO",
    			   rotation='10 KB',
    			   compression='zip',
    			   )


    	@logger.catch
    	def index(list_arr: list):
    		return list_arr[100]
    	index([1, 2, 3])
    ```

[Параметры для маршрутизаторов api router](../ЯП/Python/либы%20Python/Fast%20Api/Fast%20Api.md#Работа%20с%20маршрутизатором%20api%20router)

