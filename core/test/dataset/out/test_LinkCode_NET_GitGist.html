<head>
    <meta charset="UTF-8">
    <link href="./bootstrap-5.1.3-dist/main.css" rel="stylesheet">
    <script src="./bootstrap-5.1.3-dist/main.js"></script>
    <link rel="stylesheet" href="./main.min.css">
    <link rel="stylesheet" href="./plugin.css">
</head>
<!-- Всплывающие окно с исходным кодом из файла ------------------------------------------ -->
<div id="LinkCodeWindow" onclick="OnHide(event)">
    <div id="LinkCodeWindowDet">
        <div id="LinkCodeWindowButtonTitle">
            <div id="LinkCodeName"></div>
            <input type="button" id="LinkCodeWindowButtonHide" value="Скрыть" onclick="LinkCodeWindow.style.display='none'">
        </div>
        <pre class="code" id="LinkCodeWindowBody">
        </pre>
    </div>
</div>
<!-- ---------------------------------------------------------------------------------------- -->
Вот реальный пример, берем код из `GitGist`

<a class ="MarkdownDRY LinkCode" file="https:/gist.githubusercontent.com/denisxab/4290770428d4d34a83624f5343df87fd/raw/3fd17298a2dd382d0a2c52e4e11e2993f9b2da0b/SymmetricCrypto.py" ref="SymmetricCrypto.check_uniq_key" char_start="1074" char_end="1601">check_uniq_key</a>

<br>
<a class ="MarkdownDRY LinkCode" file="https:/gist.githubusercontent.com/denisxab/4290770428d4d34a83624f5343df87fd/raw/3fd17298a2dd382d0a2c52e4e11e2993f9b2da0b/SymmetricCrypto.py" ref="SymmetricCrypto.crypto" char_start="3224" char_end="3472">crypto</a>



<script>
/* -------------------------- Логика для LinkCode -------------------------- */
// Переменная для хранения исходного кода из файлов. Храниться в кодировки UTF-8, для экранирования спец символов
LinkSourceCode={
    "https:/gist.githubusercontent.com/denisxab/4290770428d4d34a83624f5343df87fd/raw/3fd17298a2dd382d0a2c52e4e11e2993f9b2da0b/SymmetricCrypto.py":decodeURIComponent(escape('import random\nimport secrets\nimport time\nfrom collections import deque\nfrom pprint import pprint\n\n\nclass SymmetricCrypto:\n    CHAR_ARR: tuple = (\n        \'\xd0\xb0\', \'\xd0\xb1\', \'\xd0\xb2\', \'\xd0\xb3\', \'\xd0\xb4\', \'\xd0\xb5\', \'\xd1\x91\', \'\xd0\xb6\', \'\xd0\xb7\', \'\xd0\xb8\',\n        \'\xd0\xb9\', \'\xd0\xba\', \'\xd0\xbb\', \'\xd0\xbc\', \'\xd0\xbd\', \'\xd0\xbe\', \'\xd0\xbf\', \'\xd1\x80\', \'\xd1\x81\', \'\xd1\x82\',\n        \'\xd1\x83\', \'\xd1\x84\', \'\xd1\x85\', \'\xd1\x86\', \'\xd1\x87\', \'\xd1\x88\', \'\xd1\x89\', \'\xd1\x8a\', \'\xd1\x8b\', \'\xd1\x8c\',\n        \'\xd1\x8d\', \'\xd1\x8e\', \'\xd1\x8f\', \'\xd0\x90\', \'\xd0\x91\', \'\xd0\x92\', \'\xd0\x93\', \'\xd0\x94\', \'\xd0\x95\', \'\xd0\x81\',\n        \'\xd0\x96\', \'\xd0\x97\', \'\xd0\x98\', \'\xd0\x99\', \'\xd0\x9a\', \'\xd0\x9b\', \'\xd0\x9c\', \'\xd0\x9d\', \'\xd0\x9e\', \'\xd0\x9f\',\n        \'\xd0\xa0\', \'\xd0\xa1\', \'\xd0\xa2\', \'\xd0\xa3\', \'\xd0\xa4\', \'\xd0\xa5\', \'\xd0\xa6\', \'\xd0\xa7\', \'\xd0\xa8\', \'\xd0\xa9\',\n        \'\xd0\xaa\', \'\xd0\xab\', \'\xd0\xac\', \'\xd0\xad\', \'\xd0\xae\', \'\xd0\xaf\',\n\n        \'1\', \'2\', \'3\', \'4\', \'5\', \'6\', \'7\', \'8\', \'9\', \'0\',\n        \' \', \'&\', \'?\', \'@\', \'!\', \':\', \'.\', \',\', \'\\\'\',\n        \'\\"\', \'(\', \')\', \'-\', \'+\', \'=\', \'_\', \'\xe2\x80\x93\', \'#\', \';\',\n        \'\\n\', \'\\t\', \'\\\\\', \'/\', \'|\',\n\n        \'a\', \'b\', \'c\', \'d\', \'e\', \'f\', \'g\', \'h\', \'i\', \'j\',\n        \'k\', \'l\', \'m\', \'n\', \'o\', \'p\', \'q\', \'r\', \'s\', \'t\',\n        \'u\', \'v\', \'w\', \'x\', \'y\', \'z\', \'A\', \'B\', \'C\', \'D\',\n        \'E\', \'F\', \'G\', \'H\', \'I\', \'J\', \'K\', \'L\', \'M\', \'N\',\n        \'O\', \'P\', \'Q\', \'R\', \'S\', \'T\', \'U\', \'V\', \'W\', \'X\',\n        \'Y\', \'Z\',\n    )\n\n    @staticmethod\n    def check_uniq_key(key: dict[str, list[int]]) -> bool:\n        """\n        \xd0\xa4\xd1\x83\xd0\xbd\xd0\xba\xd1\x86\xd0\xb8\xd1\x8f \xd0\xb4\xd0\xbb\xd1\x8f \xd0\xbf\xd1\x80\xd0\xbe\xd0\xb2\xd0\xb5\xd1\x80\xd0\xba\xd0\xb8 \xd1\x83\xd0\xbd\xd0\xb8\xd0\xba\xd0\xb0\xd0\xbb\xd1\x8c\xd0\xbd\xd0\xbe\xd1\x81\xd1\x82\xd0\xb8 \xd0\xb2\xd1\x81\xd0\xb5\xd1\x85 \xd0\xb7\xd0\xbd\xd0\xb0\xd1\x87\xd0\xb5\xd0\xbd\xd0\xb8\xd0\xb9 \xd0\xb2 `key`\n\n        :param key: \xd0\x92\xd0\xb7\xd1\x8f\xd1\x82\xd1\x8c \xd0\xbd\xd0\xb0\xd0\xbf\xd1\x80\xd0\xb8\xd0\xbc\xd0\xb5\xd1\x80 \xd0\xb8\xd0\xb7 \xd0\xbc\xd0\xb5\xd1\x82\xd0\xbe\xd0\xb4\xd0\xb0 `generate_random_arr()`\n        """\n        used_char: set[int] = set()\n        for _k, _v in key.items():\n            for _y in _v:\n                if not _y in used_char:\n                    used_char.add(_y)\n                else:\n                    raise ValueError(f"\xd0\xa1\xd0\xb8\xd0\xbc\xd0\xb2\xd0\xbe\xd0\xbb `{_k}` \xd1\x81\xd0\xbe\xd0\xb4\xd0\xb5\xd1\x80\xd0\xb6\xd0\xb8\xd1\x82 \xd0\xbd\xd0\xb5 \xd1\x83\xd0\xbd\xd0\xb8\xd0\xba\xd0\xb0\xd0\xbb\xd1\x8c\xd0\xbd\xd0\xbe\xd0\xb5 \xd0\xb7\xd0\xbd\xd0\xb0\xd1\x87\xd0\xb5\xd0\xbd\xd0\xb8\xd0\xb5 `{_y}`")\n        return True\n\n    @classmethod\n    def generate_random_arr(cls,\n                            len_arr: int,\n                            min_random_int: int,\n                            max_random_int: int,\n                            seed_: int = None,\n                            ) -> dict[str, list[int]]:\n        """\n        \xd0\x93\xd0\xb5\xd0\xbd\xd0\xb5\xd1\x80\xd0\xb8\xd1\x80\xd1\x83\xd0\xb5\xd0\xbc \xd1\x81\xd0\xbb\xd1\x83\xd1\x87\xd0\xb0\xd0\xb9\xd0\xbd\xd1\x8b \xd0\xb7\xd0\xbd\xd0\xb0\xd1\x87\xd0\xb5\xd0\xbd\xd0\xb8\xd0\xb9 \xd0\xb4\xd0\xbb\xd1\x8f \xd0\xba\xd0\xbb\xd1\x8e\xd1\x87\xd0\xb5\xd0\xb9 \xd1\x81\xd0\xbb\xd0\xbe\xd0\xb2\xd0\xb0\xd1\x80\xd1\x8c\n\n        :param len_arr: \xd0\x94\xd0\xbb\xd0\xb8\xd0\xbd\xd0\xbd\xd0\xb0 \xd1\x81\xd0\xbb\xd1\x83\xd1\x87\xd0\xb0\xd0\xb9\xd0\xbd\xd1\x8b\xd1\x85 \xd1\x87\xd0\xb8\xd1\x81\xd0\xb5\xd0\xbb\n        :param min_random_int: \xd0\x9c\xd0\xb8\xd0\xbd\xd0\xb8\xd0\xbc\xd0\xb0\xd0\xbb\xd1\x8c\xd0\xbd\xd0\xbe\xd0\xb5 \xd1\x87\xd0\xb8\xd1\x81\xd0\xbb\xd0\xbe \xd0\xb4\xd0\xbb\xd1\x8f  `random.randint`\n        :param max_random_int: \xd0\x9c\xd0\xb0\xd0\xba\xd1\x81\xd0\xb8\xd0\xbc\xd0\xb0\xd0\xbb\xd1\x8c\xd0\xbd\xd0\xbe\xd0\xb5 \xd1\x87\xd0\xb8\xd1\x81\xd0\xbb\xd0\xbe \xd0\xb4\xd0\xbb\xd1\x8f  `random.randint`\n        :param seed_: \xd0\x97\xd0\xb5\xd1\x80\xd0\xbd\xd0\xbe \xd0\xb4\xd0\xbb\xd1\x8f \xd0\xb3\xd0\xb5\xd0\xbd\xd0\xb5\xd1\x80\xd0\xb0\xd1\x82\xd0\xbe\xd1\x80\xd0\xb0 `random.seed(seed_)`\n        """\n\n        def get_random_arr() -> list[int]:\n            # a = [1,2,3,4]\n            tmp_arr = []\n            while len(tmp_arr) != len_arr:\n                tmp = random.randint(min_random_int, max_random_int)\n                if not tmp in used_char:\n                    used_char.add(tmp)\n                    tmp_arr.append(tmp)\n            return tmp_arr\n\n        seed_ = seed_ if seed_ else int(time.time())\n        random.seed(seed_)\n        used_char = set()\n        char_dict: dict[str, list[int]] = {}\n        for _x in cls.CHAR_ARR:\n            char_dict[_x] = get_random_arr()\n        return char_dict\n\n    @staticmethod\n    def ReverseTransectsMap(translate_map: dict[str, list[int]]) -> dict[str, str]:\n        res: dict[str, str] = {}\n        for _k, _array_value in translate_map.items():\n            for _v in _array_value:\n                res[str(_v)] = _k\n\n        # print("1", str(translate_map)[:200])\n        # print("2", str(res)[:200])\n        return res\n\n    @staticmethod\n    def crypto(text: str, translate_map: dict[str, list[int]]) -> str:\n        res: deque[str] = deque()\n        for _char in text:\n            tmp = secrets.choice(translate_map[_char])\n            res.append(str(tmp))\n        return "|".join(res)\n\n    @staticmethod\n    def decrypto(text: str, reverse_translate_map: dict[str, str]) -> str:\n        res = []\n        for _char in text.split("|"):\n            tmp = reverse_translate_map.get(_char, False)\n            if tmp:\n                res.append(tmp)\n            else:\n                raise ValueError("\xd0\x9d\xd0\xb5\xd0\xb2\xd0\xb5\xd1\x80\xd0\xbd\xd1\x8b\xd0\xb5 \xd0\xb4\xd0\xb0\xd0\xbd\xd0\xbd\xd1\x8b\xd0\xb5")\n        return "".join(res)\n\n\nif __name__ == \'__main__\':\n    res = SymmetricCrypto.generate_random_arr(len_arr=4,\n                                              seed_=444423424344444444,\n                                              min_random_int=-600,\n                                              max_random_int=888)\n    pprint(res)\n    pprint(SymmetricCrypto.check_uniq_key(res))\n\n    text = SymmetricCrypto.crypto("\xd0\x9f\xd1\x80\xd0\xb8\xd0\xb2\xd0\xb5\xd1\x82", res)\n    print(text)\n\n    reverse_translate_map = SymmetricCrypto.ReverseTransectsMap(res)\n    print(SymmetricCrypto.decrypto(text, reverse_translate_map))'))
};

function AddEventLinkCode() {
    /* Добавление обработка нажатий на ссылки */
    
    let elm = document.querySelectorAll(".MarkdownDRY.LinkCode");
    elm.forEach((e) => {
        e.addEventListener("click", () => {
            DisplayLinkCode(e);
        });
    });
}
AddEventLinkCode();
function DisplayLinkCode(_elem) {
    /* Показать всплывающие окно с исходным кодом */
    
    // Устанавливаем в заголовок всплывающего окна, название ссылки которая вызвала это окно
    LinkCodeName.textContent=_elem.textContent

    // Получаем элемент в котором будет исходный текст из файла
    let _el = document.querySelector('#LinkCodeWindowBody')
    const source_text = LinkSourceCode[_elem.getAttribute('file')]
    if (source_text) {
        // --- Вставка кода в всплывающие окно --- //
        _el.innerHTML = toTag(source_text, 'code');
        // --- Выделение кода --- //
        const char_start = _elem.getAttribute('char_start');
        const char_end = _elem.getAttribute('char_end');
        if (char_start > 0 && char_end > 0) {
            // Выделяем текст согласно диапазону из ссылки. Если конечно такой диапазон есть.
            // Его может не быть если ссылка указывает на несуществующий элемент кода.              
            const highlight_text = toTag(toTag(_el.textContent.slice(char_start, char_end), 'span'), 'code', true);
            // Собираем результат, и записываем его в тело всплывающего окна
            _el.innerHTML = `${toTag(_el.textContent.slice(0, char_start), 'code', null, null, true)}` +
                `${highlight_text}` +
                `${toTag(_el.textContent.slice(char_end, _el.innerHTML.length), 'code', null, true, null)}`
        }
        // ------------------------------------------------------------- //        
    }
    // Делаем видимым окно
    LinkCodeWindow.style.display = 'block';
    // Перебираем все строки и ищем начало выделение кода
    for (let _e of _el.childNodes) {
        if (_e.childNodes.length > 0 && _e.childNodes[0].tagName === "SPAN") {
            // Плавная прокрутка к первому выделенному блоку
            _e.scrollIntoView({ behavior: 'smooth'});
            break;
        }
    }
}
function toTag(text, tag) {
    /*Поместить текст в теги*/
    
    let list = [];
    text.split('\n').forEach(
        (_e) => {
            list.push(`<${tag}>${_e}</${tag}>`);
        }
    )
    return list.join('\n');
}

function toTag(text, tag, is_skip_first_last) {
    /*Поместить текст в теги
    
    is_skip_first_last=true - Если нужно пропустить первый и последний тег
    */
    
    let list = [];
    if (!is_skip_first_last) {
        text.split('\n').forEach(
            (_e) => {
                list.push(`<${tag}>${_e}</${tag}>`);
            }
        )
    } else {
        // Если нужно пропустить первый и последний тег
        const tmp = text.split('\n')
        list.push(tmp[0])
        tmp.slice(1, -1).forEach(
            (_e) => {
                list.push(`<${tag}>${_e}</${tag}>`);
            }
        )
        list.push(tmp[tmp.length-1])
    }
    return list.join('\n');
}
function toTag(text, tag, is_skip_first_last, skip_first, skip_last) {
    /*Поместить текст в теги

    is_skip_first_last=true - Если нужно пропустить первый и последний тег
    */

    let list = [];
    const tmp = text.split('\n');

    if (!is_skip_first_last) {
        if (skip_last) {
            tmp.slice(0, -1).forEach(
                (_e) => {
                    list.push(`<${tag}>${_e}</${tag}>`);
                }
            )
            list.push(`<${tag}>${tmp[tmp.length - 1]}`)
        } else if (skip_first) {
            list.push(`</${tag}>${tmp[0]}`)
            tmp.slice(1, -1).forEach(
                (_e) => {
                    list.push(`<${tag}>${_e}</${tag}>`);
                }
            )
        } else {
            tmp.forEach(
                (_e) => {
                    list.push(`<${tag}>${_e}</${tag}>`);
                }
            )
        }
    } else {
        // Если нужно пропустить первый и последний тег
        list.push(tmp[0])
        tmp.slice(1).forEach(
            (_e) => {
                list.push(`<${tag}>${_e}</${tag}>`);
            }
        )
        // list.push(tmp[tmp.length - 1])
    }
    return list.join('\n');
}
function OnHide(_event) {
    /* Скрыть выплывающие окно при нажатии вне его */
    
    console.log('OnHide');
    if (_event.target.id === 'LinkCodeWindow') {
        LinkCodeWindow.style.display = 'none'
    }
}

/* --------------------------------------------------------------------------------------------- */
</script>
